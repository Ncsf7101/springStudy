			Spring13
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
public class SpringConfig {
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao")  //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl implements BookDao {
    @Value("${name}")
    private String name;
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


//@Autowired //暴力反射直接暴力加值,如修改访问方式
//private BookDao bookDao2; //自动装配,先查找参数名字,后查找参数类型
//
//    @Autowired //set方法可以不用，也可以有
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    public BookDaoImpl() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ..." + name);
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao2") //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl2 implements BookDao {
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


    public BookDaoImpl2() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ...2");
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
@Service
public class BookServiceImpl implements BookService {
    @Autowired //暴力反射直接暴力加值,如修改访问方式
    @Qualifier("bookDao") //优先级又高于Autowired自带查找
    private BookDao bookDao2; //自动装配,先查找与参数名字匹配的bean,后查找参数类型匹配的bean

//    @Autowired
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    @Override
    public void save() {
        System.out.println("book service save...");
        bookDao2.save();
    }
}
 
public class App {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
//        BookDao bookDao = ctx.getBean(BookDao.class);

        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        //ctx.registerShutdownHook();
        BookService bookService = ctx.getBean(BookService.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookService.save();
        //ctx.close();
    }
}
 
public class AppForAnnotation {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        BookDao bookDao = ctx.getBean(BookDao.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookDao.save();
    }
}
 
public class AppForBeanFactory {
    public static void main(String[] args) {
        Resource resources = new ClassPathResource("applicationContext.xml"); //延迟加载Bean而 ApplicationContext是立即加载Bean
        BeanFactory bf = new XmlBeanFactory(resources);
//        BookDao bookDao = bf.getBean(BookDao.class);
//        bookDao.save();

    }
}

 
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">
<!--        1.导入spring的坐标spring-context，对应版本是5.2.10.RELEASE-->
<!--        2.配置bean-->
<!--            bean标签表示配置bean-->
<!--            id属性表示给bean起名字-->
<!--            class属性表示被bean定义类型-->


<!--     方式一：构造方法实例化bean     -->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" scope="prototype"/>-->
<!--     方式二：使用静态工厂实例化bean-->
<!--     <bean id="orderDao" class="com.rqiang.factory.OrderDaoFactory" factory-method="getOrderDao"/>-->
     <!--     方式二：使用实例工厂实例化bean-->
<!--     <bean id="userDaoFactory" class="com.rqiang.factory.UserDaoFactory"/>-->
<!--     <bean id="userDao" factory-bean="userDaoFactory" factory-method="getUserDao"/>-->
<!--     方式四： 使用FactoryBean 实例化bean-->

<!--     标准书写-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg name="connectionNum" value="100"/>-->
<!--          <constructor-arg name="databaseName" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->
<!--     解决形参名称的问题，与形参名不耦合-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg type="int" value="100"/>-->
<!--          <constructor-arg type="java.lang.String" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->

<!--     解决参数类型重复问题，使用位置解决参数匹配-->

<!--    管理DruidDateSource对象-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="url" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="username" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--    </bean>-->
<!--    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">-->
<!--        <property name="driverClass" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="user" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--        <property name="maxPoolSize" value="1000"/>-->
<!--    </bean>-->
<!--    1.开启context命名空间-->
<!--    2.使用context空间加载properties文件-->
<!--    system-properties-mode="NEVER" 不加载系统属性 ✔-->
<!--    jdbc.properties, jdbc2.properties加载多个properties文件 -->
<!--    *properties 加载所有的properties文件 ×-->
<!--    classpath:*.properties 加载资源路径下的properties文件 ✔✔-->
<!--    classpath*:*.properties 加载导入jar包及资源路径下的properties文件 ✔-->
<!--    <context:property-placeholder location="classpath*:*.properties" system-properties-mode="NEVER"/>-->
<!--&lt;!&ndash;    3.使用属性占位符${}读取properties文件中的属性&ndash;&gt;-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="${jdbc.driver}"/>-->
<!--        <property name="url" value="${jdbc.url}"/>-->
<!--        <property name="username" value="${jdbc.username}"/>-->
<!--        <property name="password" value="${jdbc.password}"/>-->
<!--    </bean>-->
<!--    lazy-init="true" 延迟加载参数-->
<!--    <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl"/>-->
<!--    核心配置文件中通过组件扫描加载bean-->
<!--    <context:component-scan base-package="com.rqiang.dao.impl"/>-->
    <context:component-scan base-package="com.rqiang"/>

<!--     自动装配用于应用类型依赖注入，不能对简单类型操作-->
<!--     按类型装配时(byType)必须保障容器中相同类型的bean唯一，推荐使用-->
<!--     按名称装配时(byName)必须保障容器中具有指定名称的bean，因为变量名和配置耦合，不推荐使用-->
<!--     自动装配autowire优先级低于setter注入与构造器注入，多种注入同时出现会自动装配配置失效-->
<!---->

     <!--        别名: <bean name="book1, book2; dao service"/>-->
<!--    spring bean 默认配置Single单例的bean对象，可以通过输出对象地址验证-->
<!--    默认为单例，可以通过修改bean配置属性更改为非单例 scope="singleton|prototype-->
<!--    如果关系绑定，不管绑定关系是什么作用范围都以IOC取出的对象Scope为准，如：bean为prototype，bookService为singleton，取出对象为singleton-->
<!--          7.配置service与dao的关系-->
<!--          property标签表示配置当前bean的属性-->
<!--          name属性表示配置哪一个具体的属性，即set+name的name方法名-->
<!--          ref属性表示参照哪一个bean-->


</beans>

<!--适合交给IOC容器管理的bean-->
<!--    表现层对象-->
<!--    业务层对象-->
<!--    数据从对象-->
<!--    工具对象-->
<!--不适合交给IOC容器管理的bean-->
<!--    封装实体的域对象-->
 
Spring14
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
//@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>   //14中:也可以使用此方法扫描另外的配置文件
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
//@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
@Import({JdbcConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {
}


public class JdbcConfig {
    //1.定义一个方法获得要管理的bean
    //2.添加@bean表示当前返回的方法是一个bean
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/db_ssm");
        ds.setUsername("root");
        ds.setPassword("123456");
        return ds;
    }
}
//1.定义一个方法获得要管理的bean
//2.添加@bean表示当前返回的方法是一个bean
@Value("com.mysql.jdbc.Driver")
private String driver;
@Value("jdbc:mysql://localhost:3306/db_ssm")
private String url;
@Value("root")
private String userName;
@Value("123456")
private String password;

@Bean
public DataSource dataSource(BookDao bookDao){ //引用类型注入: 定义方法设置形参,容器会根据类型自动装配对象
    System.out.println(bookDao);
    DruidDataSource ds = new DruidDataSource();
    ds.setDriverClassName(driver);
    ds.setUrl(url);
    ds.setUsername(userName);
    ds.setPassword(password);
    return ds;
}

 
Spirng15
public class JdbcConfig {
    @Value("${jdbc.driver}")
    public String driver;
    @Value("${jdbc.url}")
    public String url;
    @Value("${jdbc.username}")
    public String username;
    @Value("${jdbc.password}")
    public String password;

    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
 
public class MybatisConfig {

    @Bean
    public SqlSessionFactoryBean SqlSessionFactory(DataSource dataSource){
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        //ssfb.setTypeAliasesPackage("com.rqiang.domain");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer(){
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.rqiang.dao");
        return msc;
    }
}

 
@Configuration
@ComponentScan("com.rqiang")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {

}
 
public class App2 {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        AccountService accountService = ctx.getBean(AccountService.class);

        Account ac = accountService.findById(2);

        System.out.println(ac);
    }
 
Spring16
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceTest {

    @Autowired
    private AccountService accountService;

    @Test
    public void testFindById(){
        System.out.println(accountService.findById(1));
    }
}




 
Spring17
//AOP在不惊动原始程序的基础上，对其进行功能增强
    //Spring理念：无侵入式编程

通知类-----通知 ---–（切面）----> 切入点匹配---连接点

连接点(JoinPoint): 程序执行过程中任意的位置，粒度为执行方法、抛出异常、设置变量等
在SpringAOP中，理解为方法的执行

切入点(Pointcut): 匹配连接点的式子
在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法
一个具体方法: com.rqiang.dao包下的BookDao接口中的无形参无返回值的save方法
匹配多个方法: 所有的save方法，所有的get开头的方法，所有的Dao结尾的接口中的任意方法，所有带有一个参数的方法

通知(Advice): 在切入点处执行的操作，也就是共性功能
  在SpringAOP中, 功能最终以方法的形式呈现

通知类: 定义通知的类

切面(Aspect): 描述通知与切入点的对应关系
 
Spring18




 
			Spring13
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
public class SpringConfig {
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao")  //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl implements BookDao {
    @Value("${name}")
    private String name;
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


//@Autowired //暴力反射直接暴力加值,如修改访问方式
//private BookDao bookDao2; //自动装配,先查找参数名字,后查找参数类型
//
//    @Autowired //set方法可以不用，也可以有
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    public BookDaoImpl() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ..." + name);
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao2") //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl2 implements BookDao {
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


    public BookDaoImpl2() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ...2");
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
@Service
public class BookServiceImpl implements BookService {
    @Autowired //暴力反射直接暴力加值,如修改访问方式
    @Qualifier("bookDao") //优先级又高于Autowired自带查找
    private BookDao bookDao2; //自动装配,先查找与参数名字匹配的bean,后查找参数类型匹配的bean

//    @Autowired
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    @Override
    public void save() {
        System.out.println("book service save...");
        bookDao2.save();
    }
}
 
public class App {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
//        BookDao bookDao = ctx.getBean(BookDao.class);

        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        //ctx.registerShutdownHook();
        BookService bookService = ctx.getBean(BookService.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookService.save();
        //ctx.close();
    }
}
 
public class AppForAnnotation {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        BookDao bookDao = ctx.getBean(BookDao.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookDao.save();
    }
}
 
public class AppForBeanFactory {
    public static void main(String[] args) {
        Resource resources = new ClassPathResource("applicationContext.xml"); //延迟加载Bean而 ApplicationContext是立即加载Bean
        BeanFactory bf = new XmlBeanFactory(resources);
//        BookDao bookDao = bf.getBean(BookDao.class);
//        bookDao.save();

    }
}

 
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">
<!--        1.导入spring的坐标spring-context，对应版本是5.2.10.RELEASE-->
<!--        2.配置bean-->
<!--            bean标签表示配置bean-->
<!--            id属性表示给bean起名字-->
<!--            class属性表示被bean定义类型-->


<!--     方式一：构造方法实例化bean     -->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" scope="prototype"/>-->
<!--     方式二：使用静态工厂实例化bean-->
<!--     <bean id="orderDao" class="com.rqiang.factory.OrderDaoFactory" factory-method="getOrderDao"/>-->
     <!--     方式二：使用实例工厂实例化bean-->
<!--     <bean id="userDaoFactory" class="com.rqiang.factory.UserDaoFactory"/>-->
<!--     <bean id="userDao" factory-bean="userDaoFactory" factory-method="getUserDao"/>-->
<!--     方式四： 使用FactoryBean 实例化bean-->

<!--     标准书写-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg name="connectionNum" value="100"/>-->
<!--          <constructor-arg name="databaseName" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->
<!--     解决形参名称的问题，与形参名不耦合-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg type="int" value="100"/>-->
<!--          <constructor-arg type="java.lang.String" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->

<!--     解决参数类型重复问题，使用位置解决参数匹配-->

<!--    管理DruidDateSource对象-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="url" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="username" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--    </bean>-->
<!--    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">-->
<!--        <property name="driverClass" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="user" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--        <property name="maxPoolSize" value="1000"/>-->
<!--    </bean>-->
<!--    1.开启context命名空间-->
<!--    2.使用context空间加载properties文件-->
<!--    system-properties-mode="NEVER" 不加载系统属性 ✔-->
<!--    jdbc.properties, jdbc2.properties加载多个properties文件 -->
<!--    *properties 加载所有的properties文件 ×-->
<!--    classpath:*.properties 加载资源路径下的properties文件 ✔✔-->
<!--    classpath*:*.properties 加载导入jar包及资源路径下的properties文件 ✔-->
<!--    <context:property-placeholder location="classpath*:*.properties" system-properties-mode="NEVER"/>-->
<!--&lt;!&ndash;    3.使用属性占位符${}读取properties文件中的属性&ndash;&gt;-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="${jdbc.driver}"/>-->
<!--        <property name="url" value="${jdbc.url}"/>-->
<!--        <property name="username" value="${jdbc.username}"/>-->
<!--        <property name="password" value="${jdbc.password}"/>-->
<!--    </bean>-->
<!--    lazy-init="true" 延迟加载参数-->
<!--    <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl"/>-->
<!--    核心配置文件中通过组件扫描加载bean-->
<!--    <context:component-scan base-package="com.rqiang.dao.impl"/>-->
    <context:component-scan base-package="com.rqiang"/>

<!--     自动装配用于应用类型依赖注入，不能对简单类型操作-->
<!--     按类型装配时(byType)必须保障容器中相同类型的bean唯一，推荐使用-->
<!--     按名称装配时(byName)必须保障容器中具有指定名称的bean，因为变量名和配置耦合，不推荐使用-->
<!--     自动装配autowire优先级低于setter注入与构造器注入，多种注入同时出现会自动装配配置失效-->
<!---->

     <!--        别名: <bean name="book1, book2; dao service"/>-->
<!--    spring bean 默认配置Single单例的bean对象，可以通过输出对象地址验证-->
<!--    默认为单例，可以通过修改bean配置属性更改为非单例 scope="singleton|prototype-->
<!--    如果关系绑定，不管绑定关系是什么作用范围都以IOC取出的对象Scope为准，如：bean为prototype，bookService为singleton，取出对象为singleton-->
<!--          7.配置service与dao的关系-->
<!--          property标签表示配置当前bean的属性-->
<!--          name属性表示配置哪一个具体的属性，即set+name的name方法名-->
<!--          ref属性表示参照哪一个bean-->


</beans>

<!--适合交给IOC容器管理的bean-->
<!--    表现层对象-->
<!--    业务层对象-->
<!--    数据从对象-->
<!--    工具对象-->
<!--不适合交给IOC容器管理的bean-->
<!--    封装实体的域对象-->
 
Spring14
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
//@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>   //14中:也可以使用此方法扫描另外的配置文件
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
//@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
@Import({JdbcConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {
}


public class JdbcConfig {
    //1.定义一个方法获得要管理的bean
    //2.添加@bean表示当前返回的方法是一个bean
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/db_ssm");
        ds.setUsername("root");
        ds.setPassword("123456");
        return ds;
    }
}
//1.定义一个方法获得要管理的bean
//2.添加@bean表示当前返回的方法是一个bean
@Value("com.mysql.jdbc.Driver")
private String driver;
@Value("jdbc:mysql://localhost:3306/db_ssm")
private String url;
@Value("root")
private String userName;
@Value("123456")
private String password;

@Bean
public DataSource dataSource(BookDao bookDao){ //引用类型注入: 定义方法设置形参,容器会根据类型自动装配对象
    System.out.println(bookDao);
    DruidDataSource ds = new DruidDataSource();
    ds.setDriverClassName(driver);
    ds.setUrl(url);
    ds.setUsername(userName);
    ds.setPassword(password);
    return ds;
}

 
Spirng15
public class JdbcConfig {
    @Value("${jdbc.driver}")
    public String driver;
    @Value("${jdbc.url}")
    public String url;
    @Value("${jdbc.username}")
    public String username;
    @Value("${jdbc.password}")
    public String password;

    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
 
public class MybatisConfig {

    @Bean
    public SqlSessionFactoryBean SqlSessionFactory(DataSource dataSource){
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        //ssfb.setTypeAliasesPackage("com.rqiang.domain");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer(){
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.rqiang.dao");
        return msc;
    }
}

 
@Configuration
@ComponentScan("com.rqiang")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {

}
 
public class App2 {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        AccountService accountService = ctx.getBean(AccountService.class);

        Account ac = accountService.findById(2);

        System.out.println(ac);
    }
 
Spring16
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceTest {

    @Autowired
    private AccountService accountService;

    @Test
    public void testFindById(){
        System.out.println(accountService.findById(1));
    }
}




 
Spring17
//AOP在不惊动原始程序的基础上，对其进行功能增强
    //Spring理念：无侵入式编程

通知类-----通知 ---–（切面）----> 切入点匹配---连接点

连接点(JoinPoint): 程序执行过程中任意的位置，粒度为执行方法、抛出异常、设置变量等
在SpringAOP中，理解为方法的执行

切入点(Pointcut): 匹配连接点的式子
在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法
一个具体方法: com.rqiang.dao包下的BookDao接口中的无形参无返回值的save方法
匹配多个方法: 所有的save方法，所有的get开头的方法，所有的Dao结尾的接口中的任意方法，所有带有一个参数的方法

通知(Advice): 在切入点处执行的操作，也就是共性功能
  在SpringAOP中, 功能最终以方法的形式呈现

通知类: 定义通知的类

切面(Aspect): 描述通知与切入点的对应关系
 
Spring18





 
			Spring13
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
public class SpringConfig {
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao")  //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl implements BookDao {
    @Value("${name}")
    private String name;
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


//@Autowired //暴力反射直接暴力加值,如修改访问方式
//private BookDao bookDao2; //自动装配,先查找参数名字,后查找参数类型
//
//    @Autowired //set方法可以不用，也可以有
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    public BookDaoImpl() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ..." + name);
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao2") //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl2 implements BookDao {
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


    public BookDaoImpl2() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ...2");
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
@Service
public class BookServiceImpl implements BookService {
    @Autowired //暴力反射直接暴力加值,如修改访问方式
    @Qualifier("bookDao") //优先级又高于Autowired自带查找
    private BookDao bookDao2; //自动装配,先查找与参数名字匹配的bean,后查找参数类型匹配的bean

//    @Autowired
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    @Override
    public void save() {
        System.out.println("book service save...");
        bookDao2.save();
    }
}
 
public class App {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
//        BookDao bookDao = ctx.getBean(BookDao.class);

        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        //ctx.registerShutdownHook();
        BookService bookService = ctx.getBean(BookService.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookService.save();
        //ctx.close();
    }
}
 
public class AppForAnnotation {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        BookDao bookDao = ctx.getBean(BookDao.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookDao.save();
    }
}
 
public class AppForBeanFactory {
    public static void main(String[] args) {
        Resource resources = new ClassPathResource("applicationContext.xml"); //延迟加载Bean而 ApplicationContext是立即加载Bean
        BeanFactory bf = new XmlBeanFactory(resources);
//        BookDao bookDao = bf.getBean(BookDao.class);
//        bookDao.save();

    }
}

 
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">
<!--        1.导入spring的坐标spring-context，对应版本是5.2.10.RELEASE-->
<!--        2.配置bean-->
<!--            bean标签表示配置bean-->
<!--            id属性表示给bean起名字-->
<!--            class属性表示被bean定义类型-->


<!--     方式一：构造方法实例化bean     -->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" scope="prototype"/>-->
<!--     方式二：使用静态工厂实例化bean-->
<!--     <bean id="orderDao" class="com.rqiang.factory.OrderDaoFactory" factory-method="getOrderDao"/>-->
     <!--     方式二：使用实例工厂实例化bean-->
<!--     <bean id="userDaoFactory" class="com.rqiang.factory.UserDaoFactory"/>-->
<!--     <bean id="userDao" factory-bean="userDaoFactory" factory-method="getUserDao"/>-->
<!--     方式四： 使用FactoryBean 实例化bean-->

<!--     标准书写-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg name="connectionNum" value="100"/>-->
<!--          <constructor-arg name="databaseName" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->
<!--     解决形参名称的问题，与形参名不耦合-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg type="int" value="100"/>-->
<!--          <constructor-arg type="java.lang.String" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->

<!--     解决参数类型重复问题，使用位置解决参数匹配-->

<!--    管理DruidDateSource对象-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="url" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="username" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--    </bean>-->
<!--    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">-->
<!--        <property name="driverClass" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="user" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--        <property name="maxPoolSize" value="1000"/>-->
<!--    </bean>-->
<!--    1.开启context命名空间-->
<!--    2.使用context空间加载properties文件-->
<!--    system-properties-mode="NEVER" 不加载系统属性 ✔-->
<!--    jdbc.properties, jdbc2.properties加载多个properties文件 -->
<!--    *properties 加载所有的properties文件 ×-->
<!--    classpath:*.properties 加载资源路径下的properties文件 ✔✔-->
<!--    classpath*:*.properties 加载导入jar包及资源路径下的properties文件 ✔-->
<!--    <context:property-placeholder location="classpath*:*.properties" system-properties-mode="NEVER"/>-->
<!--&lt;!&ndash;    3.使用属性占位符${}读取properties文件中的属性&ndash;&gt;-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="${jdbc.driver}"/>-->
<!--        <property name="url" value="${jdbc.url}"/>-->
<!--        <property name="username" value="${jdbc.username}"/>-->
<!--        <property name="password" value="${jdbc.password}"/>-->
<!--    </bean>-->
<!--    lazy-init="true" 延迟加载参数-->
<!--    <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl"/>-->
<!--    核心配置文件中通过组件扫描加载bean-->
<!--    <context:component-scan base-package="com.rqiang.dao.impl"/>-->
    <context:component-scan base-package="com.rqiang"/>

<!--     自动装配用于应用类型依赖注入，不能对简单类型操作-->
<!--     按类型装配时(byType)必须保障容器中相同类型的bean唯一，推荐使用-->
<!--     按名称装配时(byName)必须保障容器中具有指定名称的bean，因为变量名和配置耦合，不推荐使用-->
<!--     自动装配autowire优先级低于setter注入与构造器注入，多种注入同时出现会自动装配配置失效-->
<!---->

     <!--        别名: <bean name="book1, book2; dao service"/>-->
<!--    spring bean 默认配置Single单例的bean对象，可以通过输出对象地址验证-->
<!--    默认为单例，可以通过修改bean配置属性更改为非单例 scope="singleton|prototype-->
<!--    如果关系绑定，不管绑定关系是什么作用范围都以IOC取出的对象Scope为准，如：bean为prototype，bookService为singleton，取出对象为singleton-->
<!--          7.配置service与dao的关系-->
<!--          property标签表示配置当前bean的属性-->
<!--          name属性表示配置哪一个具体的属性，即set+name的name方法名-->
<!--          ref属性表示参照哪一个bean-->


</beans>

<!--适合交给IOC容器管理的bean-->
<!--    表现层对象-->
<!--    业务层对象-->
<!--    数据从对象-->
<!--    工具对象-->
<!--不适合交给IOC容器管理的bean-->
<!--    封装实体的域对象-->
 
Spring14
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
//@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>   //14中:也可以使用此方法扫描另外的配置文件
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
//@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
@Import({JdbcConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {
}


public class JdbcConfig {
    //1.定义一个方法获得要管理的bean
    //2.添加@bean表示当前返回的方法是一个bean
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/db_ssm");
        ds.setUsername("root");
        ds.setPassword("123456");
        return ds;
    }
}
//1.定义一个方法获得要管理的bean
//2.添加@bean表示当前返回的方法是一个bean
@Value("com.mysql.jdbc.Driver")
private String driver;
@Value("jdbc:mysql://localhost:3306/db_ssm")
private String url;
@Value("root")
private String userName;
@Value("123456")
private String password;

@Bean
public DataSource dataSource(BookDao bookDao){ //引用类型注入: 定义方法设置形参,容器会根据类型自动装配对象
    System.out.println(bookDao);
    DruidDataSource ds = new DruidDataSource();
    ds.setDriverClassName(driver);
    ds.setUrl(url);
    ds.setUsername(userName);
    ds.setPassword(password);
    return ds;
}

 
Spirng15
public class JdbcConfig {
    @Value("${jdbc.driver}")
    public String driver;
    @Value("${jdbc.url}")
    public String url;
    @Value("${jdbc.username}")
    public String username;
    @Value("${jdbc.password}")
    public String password;

    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
 
public class MybatisConfig {

    @Bean
    public SqlSessionFactoryBean SqlSessionFactory(DataSource dataSource){
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        //ssfb.setTypeAliasesPackage("com.rqiang.domain");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer(){
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.rqiang.dao");
        return msc;
    }
}

 
@Configuration
@ComponentScan("com.rqiang")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {

}
 
public class App2 {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        AccountService accountService = ctx.getBean(AccountService.class);

        Account ac = accountService.findById(2);

        System.out.println(ac);
    }
 
Spring16
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceTest {

    @Autowired
    private AccountService accountService;

    @Test
    public void testFindById(){
        System.out.println(accountService.findById(1));
    }
}




 
Spring17
//AOP在不惊动原始程序的基础上，对其进行功能增强
    //Spring理念：无侵入式编程

通知类-----通知 ---–（切面）----> 切入点匹配---连接点

连接点(JoinPoint): 程序执行过程中任意的位置，粒度为执行方法、抛出异常、设置变量等
在SpringAOP中，理解为方法的执行

切入点(Pointcut): 匹配连接点的式子
在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法
一个具体方法: com.rqiang.dao包下的BookDao接口中的无形参无返回值的save方法
匹配多个方法: 所有的save方法，所有的get开头的方法，所有的Dao结尾的接口中的任意方法，所有带有一个参数的方法

通知(Advice): 在切入点处执行的操作，也就是共性功能
  在SpringAOP中, 功能最终以方法的形式呈现

通知类: 定义通知的类

切面(Aspect): 描述通知与切入点的对应关系
 
Spring18





 
			Spring13
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
public class SpringConfig {
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao")  //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl implements BookDao {
    @Value("${name}")
    private String name;
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


//@Autowired //暴力反射直接暴力加值,如修改访问方式
//private BookDao bookDao2; //自动装配,先查找参数名字,后查找参数类型
//
//    @Autowired //set方法可以不用，也可以有
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    public BookDaoImpl() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ..." + name);
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao2") //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl2 implements BookDao {
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


    public BookDaoImpl2() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ...2");
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
@Service
public class BookServiceImpl implements BookService {
    @Autowired //暴力反射直接暴力加值,如修改访问方式
    @Qualifier("bookDao") //优先级又高于Autowired自带查找
    private BookDao bookDao2; //自动装配,先查找与参数名字匹配的bean,后查找参数类型匹配的bean

//    @Autowired
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    @Override
    public void save() {
        System.out.println("book service save...");
        bookDao2.save();
    }
}
 
public class App {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
//        BookDao bookDao = ctx.getBean(BookDao.class);

        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        //ctx.registerShutdownHook();
        BookService bookService = ctx.getBean(BookService.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookService.save();
        //ctx.close();
    }
}
 
public class AppForAnnotation {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        BookDao bookDao = ctx.getBean(BookDao.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookDao.save();
    }
}
 
public class AppForBeanFactory {
    public static void main(String[] args) {
        Resource resources = new ClassPathResource("applicationContext.xml"); //延迟加载Bean而 ApplicationContext是立即加载Bean
        BeanFactory bf = new XmlBeanFactory(resources);
//        BookDao bookDao = bf.getBean(BookDao.class);
//        bookDao.save();

    }
}

 
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">
<!--        1.导入spring的坐标spring-context，对应版本是5.2.10.RELEASE-->
<!--        2.配置bean-->
<!--            bean标签表示配置bean-->
<!--            id属性表示给bean起名字-->
<!--            class属性表示被bean定义类型-->


<!--     方式一：构造方法实例化bean     -->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" scope="prototype"/>-->
<!--     方式二：使用静态工厂实例化bean-->
<!--     <bean id="orderDao" class="com.rqiang.factory.OrderDaoFactory" factory-method="getOrderDao"/>-->
     <!--     方式二：使用实例工厂实例化bean-->
<!--     <bean id="userDaoFactory" class="com.rqiang.factory.UserDaoFactory"/>-->
<!--     <bean id="userDao" factory-bean="userDaoFactory" factory-method="getUserDao"/>-->
<!--     方式四： 使用FactoryBean 实例化bean-->

<!--     标准书写-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg name="connectionNum" value="100"/>-->
<!--          <constructor-arg name="databaseName" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->
<!--     解决形参名称的问题，与形参名不耦合-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg type="int" value="100"/>-->
<!--          <constructor-arg type="java.lang.String" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->

<!--     解决参数类型重复问题，使用位置解决参数匹配-->

<!--    管理DruidDateSource对象-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="url" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="username" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--    </bean>-->
<!--    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">-->
<!--        <property name="driverClass" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="user" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--        <property name="maxPoolSize" value="1000"/>-->
<!--    </bean>-->
<!--    1.开启context命名空间-->
<!--    2.使用context空间加载properties文件-->
<!--    system-properties-mode="NEVER" 不加载系统属性 ✔-->
<!--    jdbc.properties, jdbc2.properties加载多个properties文件 -->
<!--    *properties 加载所有的properties文件 ×-->
<!--    classpath:*.properties 加载资源路径下的properties文件 ✔✔-->
<!--    classpath*:*.properties 加载导入jar包及资源路径下的properties文件 ✔-->
<!--    <context:property-placeholder location="classpath*:*.properties" system-properties-mode="NEVER"/>-->
<!--&lt;!&ndash;    3.使用属性占位符${}读取properties文件中的属性&ndash;&gt;-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="${jdbc.driver}"/>-->
<!--        <property name="url" value="${jdbc.url}"/>-->
<!--        <property name="username" value="${jdbc.username}"/>-->
<!--        <property name="password" value="${jdbc.password}"/>-->
<!--    </bean>-->
<!--    lazy-init="true" 延迟加载参数-->
<!--    <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl"/>-->
<!--    核心配置文件中通过组件扫描加载bean-->
<!--    <context:component-scan base-package="com.rqiang.dao.impl"/>-->
    <context:component-scan base-package="com.rqiang"/>

<!--     自动装配用于应用类型依赖注入，不能对简单类型操作-->
<!--     按类型装配时(byType)必须保障容器中相同类型的bean唯一，推荐使用-->
<!--     按名称装配时(byName)必须保障容器中具有指定名称的bean，因为变量名和配置耦合，不推荐使用-->
<!--     自动装配autowire优先级低于setter注入与构造器注入，多种注入同时出现会自动装配配置失效-->
<!---->

     <!--        别名: <bean name="book1, book2; dao service"/>-->
<!--    spring bean 默认配置Single单例的bean对象，可以通过输出对象地址验证-->
<!--    默认为单例，可以通过修改bean配置属性更改为非单例 scope="singleton|prototype-->
<!--    如果关系绑定，不管绑定关系是什么作用范围都以IOC取出的对象Scope为准，如：bean为prototype，bookService为singleton，取出对象为singleton-->
<!--          7.配置service与dao的关系-->
<!--          property标签表示配置当前bean的属性-->
<!--          name属性表示配置哪一个具体的属性，即set+name的name方法名-->
<!--          ref属性表示参照哪一个bean-->


</beans>

<!--适合交给IOC容器管理的bean-->
<!--    表现层对象-->
<!--    业务层对象-->
<!--    数据从对象-->
<!--    工具对象-->
<!--不适合交给IOC容器管理的bean-->
<!--    封装实体的域对象-->
 
Spring14
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
//@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>   //14中:也可以使用此方法扫描另外的配置文件
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
//@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
@Import({JdbcConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {
}


public class JdbcConfig {
    //1.定义一个方法获得要管理的bean
    //2.添加@bean表示当前返回的方法是一个bean
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/db_ssm");
        ds.setUsername("root");
        ds.setPassword("123456");
        return ds;
    }
}
//1.定义一个方法获得要管理的bean
//2.添加@bean表示当前返回的方法是一个bean
@Value("com.mysql.jdbc.Driver")
private String driver;
@Value("jdbc:mysql://localhost:3306/db_ssm")
private String url;
@Value("root")
private String userName;
@Value("123456")
private String password;

@Bean
public DataSource dataSource(BookDao bookDao){ //引用类型注入: 定义方法设置形参,容器会根据类型自动装配对象
    System.out.println(bookDao);
    DruidDataSource ds = new DruidDataSource();
    ds.setDriverClassName(driver);
    ds.setUrl(url);
    ds.setUsername(userName);
    ds.setPassword(password);
    return ds;
}

 
Spirng15
public class JdbcConfig {
    @Value("${jdbc.driver}")
    public String driver;
    @Value("${jdbc.url}")
    public String url;
    @Value("${jdbc.username}")
    public String username;
    @Value("${jdbc.password}")
    public String password;

    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
 
public class MybatisConfig {

    @Bean
    public SqlSessionFactoryBean SqlSessionFactory(DataSource dataSource){
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        //ssfb.setTypeAliasesPackage("com.rqiang.domain");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer(){
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.rqiang.dao");
        return msc;
    }
}

 
@Configuration
@ComponentScan("com.rqiang")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {

}
 
public class App2 {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        AccountService accountService = ctx.getBean(AccountService.class);

        Account ac = accountService.findById(2);

        System.out.println(ac);
    }
 
Spring16
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceTest {

    @Autowired
    private AccountService accountService;

    @Test
    public void testFindById(){
        System.out.println(accountService.findById(1));
    }
}




 
Spring17
//AOP在不惊动原始程序的基础上，对其进行功能增强
    //Spring理念：无侵入式编程

通知类-----通知 ---–（切面）----> 切入点匹配---连接点

连接点(JoinPoint): 程序执行过程中任意的位置，粒度为执行方法、抛出异常、设置变量等
在SpringAOP中，理解为方法的执行

切入点(Pointcut): 匹配连接点的式子
在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法
一个具体方法: com.rqiang.dao包下的BookDao接口中的无形参无返回值的save方法
匹配多个方法: 所有的save方法，所有的get开头的方法，所有的Dao结尾的接口中的任意方法，所有带有一个参数的方法

通知(Advice): 在切入点处执行的操作，也就是共性功能
  在SpringAOP中, 功能最终以方法的形式呈现

通知类: 定义通知的类

切面(Aspect): 描述通知与切入点的对应关系
 
Spring18






 
			Spring13
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
public class SpringConfig {
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao")  //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl implements BookDao {
    @Value("${name}")
    private String name;
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


//@Autowired //暴力反射直接暴力加值,如修改访问方式
//private BookDao bookDao2; //自动装配,先查找参数名字,后查找参数类型
//
//    @Autowired //set方法可以不用，也可以有
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    public BookDaoImpl() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ..." + name);
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao2") //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl2 implements BookDao {
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


    public BookDaoImpl2() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ...2");
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
@Service
public class BookServiceImpl implements BookService {
    @Autowired //暴力反射直接暴力加值,如修改访问方式
    @Qualifier("bookDao") //优先级又高于Autowired自带查找
    private BookDao bookDao2; //自动装配,先查找与参数名字匹配的bean,后查找参数类型匹配的bean

//    @Autowired
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    @Override
    public void save() {
        System.out.println("book service save...");
        bookDao2.save();
    }
}
 
public class App {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
//        BookDao bookDao = ctx.getBean(BookDao.class);

        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        //ctx.registerShutdownHook();
        BookService bookService = ctx.getBean(BookService.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookService.save();
        //ctx.close();
    }
}
 
public class AppForAnnotation {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        BookDao bookDao = ctx.getBean(BookDao.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookDao.save();
    }
}
 
public class AppForBeanFactory {
    public static void main(String[] args) {
        Resource resources = new ClassPathResource("applicationContext.xml"); //延迟加载Bean而 ApplicationContext是立即加载Bean
        BeanFactory bf = new XmlBeanFactory(resources);
//        BookDao bookDao = bf.getBean(BookDao.class);
//        bookDao.save();

    }
}

 
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">
<!--        1.导入spring的坐标spring-context，对应版本是5.2.10.RELEASE-->
<!--        2.配置bean-->
<!--            bean标签表示配置bean-->
<!--            id属性表示给bean起名字-->
<!--            class属性表示被bean定义类型-->


<!--     方式一：构造方法实例化bean     -->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" scope="prototype"/>-->
<!--     方式二：使用静态工厂实例化bean-->
<!--     <bean id="orderDao" class="com.rqiang.factory.OrderDaoFactory" factory-method="getOrderDao"/>-->
     <!--     方式二：使用实例工厂实例化bean-->
<!--     <bean id="userDaoFactory" class="com.rqiang.factory.UserDaoFactory"/>-->
<!--     <bean id="userDao" factory-bean="userDaoFactory" factory-method="getUserDao"/>-->
<!--     方式四： 使用FactoryBean 实例化bean-->

<!--     标准书写-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg name="connectionNum" value="100"/>-->
<!--          <constructor-arg name="databaseName" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->
<!--     解决形参名称的问题，与形参名不耦合-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg type="int" value="100"/>-->
<!--          <constructor-arg type="java.lang.String" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->

<!--     解决参数类型重复问题，使用位置解决参数匹配-->

<!--    管理DruidDateSource对象-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="url" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="username" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--    </bean>-->
<!--    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">-->
<!--        <property name="driverClass" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="user" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--        <property name="maxPoolSize" value="1000"/>-->
<!--    </bean>-->
<!--    1.开启context命名空间-->
<!--    2.使用context空间加载properties文件-->
<!--    system-properties-mode="NEVER" 不加载系统属性 ✔-->
<!--    jdbc.properties, jdbc2.properties加载多个properties文件 -->
<!--    *properties 加载所有的properties文件 ×-->
<!--    classpath:*.properties 加载资源路径下的properties文件 ✔✔-->
<!--    classpath*:*.properties 加载导入jar包及资源路径下的properties文件 ✔-->
<!--    <context:property-placeholder location="classpath*:*.properties" system-properties-mode="NEVER"/>-->
<!--&lt;!&ndash;    3.使用属性占位符${}读取properties文件中的属性&ndash;&gt;-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="${jdbc.driver}"/>-->
<!--        <property name="url" value="${jdbc.url}"/>-->
<!--        <property name="username" value="${jdbc.username}"/>-->
<!--        <property name="password" value="${jdbc.password}"/>-->
<!--    </bean>-->
<!--    lazy-init="true" 延迟加载参数-->
<!--    <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl"/>-->
<!--    核心配置文件中通过组件扫描加载bean-->
<!--    <context:component-scan base-package="com.rqiang.dao.impl"/>-->
    <context:component-scan base-package="com.rqiang"/>

<!--     自动装配用于应用类型依赖注入，不能对简单类型操作-->
<!--     按类型装配时(byType)必须保障容器中相同类型的bean唯一，推荐使用-->
<!--     按名称装配时(byName)必须保障容器中具有指定名称的bean，因为变量名和配置耦合，不推荐使用-->
<!--     自动装配autowire优先级低于setter注入与构造器注入，多种注入同时出现会自动装配配置失效-->
<!---->

     <!--        别名: <bean name="book1, book2; dao service"/>-->
<!--    spring bean 默认配置Single单例的bean对象，可以通过输出对象地址验证-->
<!--    默认为单例，可以通过修改bean配置属性更改为非单例 scope="singleton|prototype-->
<!--    如果关系绑定，不管绑定关系是什么作用范围都以IOC取出的对象Scope为准，如：bean为prototype，bookService为singleton，取出对象为singleton-->
<!--          7.配置service与dao的关系-->
<!--          property标签表示配置当前bean的属性-->
<!--          name属性表示配置哪一个具体的属性，即set+name的name方法名-->
<!--          ref属性表示参照哪一个bean-->


</beans>

<!--适合交给IOC容器管理的bean-->
<!--    表现层对象-->
<!--    业务层对象-->
<!--    数据从对象-->
<!--    工具对象-->
<!--不适合交给IOC容器管理的bean-->
<!--    封装实体的域对象-->
 
Spring14
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
//@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>   //14中:也可以使用此方法扫描另外的配置文件
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
//@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
@Import({JdbcConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {
}


public class JdbcConfig {
    //1.定义一个方法获得要管理的bean
    //2.添加@bean表示当前返回的方法是一个bean
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/db_ssm");
        ds.setUsername("root");
        ds.setPassword("123456");
        return ds;
    }
}
//1.定义一个方法获得要管理的bean
//2.添加@bean表示当前返回的方法是一个bean
@Value("com.mysql.jdbc.Driver")
private String driver;
@Value("jdbc:mysql://localhost:3306/db_ssm")
private String url;
@Value("root")
private String userName;
@Value("123456")
private String password;

@Bean
public DataSource dataSource(BookDao bookDao){ //引用类型注入: 定义方法设置形参,容器会根据类型自动装配对象
    System.out.println(bookDao);
    DruidDataSource ds = new DruidDataSource();
    ds.setDriverClassName(driver);
    ds.setUrl(url);
    ds.setUsername(userName);
    ds.setPassword(password);
    return ds;
}

 
Spirng15
public class JdbcConfig {
    @Value("${jdbc.driver}")
    public String driver;
    @Value("${jdbc.url}")
    public String url;
    @Value("${jdbc.username}")
    public String username;
    @Value("${jdbc.password}")
    public String password;

    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
 
public class MybatisConfig {

    @Bean
    public SqlSessionFactoryBean SqlSessionFactory(DataSource dataSource){
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        //ssfb.setTypeAliasesPackage("com.rqiang.domain");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer(){
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.rqiang.dao");
        return msc;
    }
}

 
@Configuration
@ComponentScan("com.rqiang")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {

}
 
public class App2 {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        AccountService accountService = ctx.getBean(AccountService.class);

        Account ac = accountService.findById(2);

        System.out.println(ac);
    }
 
Spring16
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceTest {

    @Autowired
    private AccountService accountService;

    @Test
    public void testFindById(){
        System.out.println(accountService.findById(1));
    }
}




 
Spring17
//AOP在不惊动原始程序的基础上，对其进行功能增强
    //Spring理念：无侵入式编程

通知类-----通知 ---–（切面）----> 切入点匹配---连接点

连接点(JoinPoint): 程序执行过程中任意的位置，粒度为执行方法、抛出异常、设置变量等
在SpringAOP中，理解为方法的执行

切入点(Pointcut): 匹配连接点的式子
在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法
一个具体方法: com.rqiang.dao包下的BookDao接口中的无形参无返回值的save方法
匹配多个方法: 所有的save方法，所有的get开头的方法，所有的Dao结尾的接口中的任意方法，所有带有一个参数的方法

通知(Advice): 在切入点处执行的操作，也就是共性功能
  在SpringAOP中, 功能最终以方法的形式呈现

通知类: 定义通知的类

切面(Aspect): 描述通知与切入点的对应关系
 
Spring18



 
			Spring13
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
public class SpringConfig {
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao")  //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl implements BookDao {
    @Value("${name}")
    private String name;
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


//@Autowired //暴力反射直接暴力加值,如修改访问方式
//private BookDao bookDao2; //自动装配,先查找参数名字,后查找参数类型
//
//    @Autowired //set方法可以不用，也可以有
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    public BookDaoImpl() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ..." + name);
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
/**
 * @Spring提供@Component注解的三个衍生注解
 * @Controller: 用于表现层bean定义
 * @Service: 用于业务层bean定义
 * @Respository: 用于数据层bean定义
 */
//@Repository //按类型查找,无法按名称查找
@Repository("bookDao2") //可以通过名称查找或者类型查找都行
@Scope("singleton")
public class BookDaoImpl2 implements BookDao {
//    private int connectionNum;
//    private String databaseName;
//
//    public BookDaoImpl(int connectionNum, String databaseName) {
//        this.connectionNum = connectionNum;
//        this.databaseName = databaseName;
//    }
//    private int[] array;
//    private List<String> list;
//    private Set<String> set;
//    private Map<String, String> map;
//    private Properties properties;
//
//    public void setArray(int[] array) {
//        this.array = array;
//    }
//
//    public void setList(List<String> list) {
//        this.list = list;
//    }
//
//    public void setSet(Set<String> set) {
//        this.set = set;
//    }
//
//    public void setMap(Map<String, String> map) {
//        this.map = map;
//    }
//
//    public void setProperties(Properties properties) {
//        this.properties = properties;
//    }


    public BookDaoImpl2() {
        System.out.println("constructor");

    }

    @Override
    public void save() {
//        System.out.println("book dao save ...");
//        System.out.println("遍历数组：" + Arrays.toString(array));
//        System.out.println("遍历List" + list);
//        System.out.println("遍历Set" + set);
//        System.out.println("遍历Map" + map);
//        System.out.println("遍历Properties" + properties);

        System.out.println("book dao save ...2");
        //System.out.println("book dao save ..." + databaseName + ", " + connectionNum);
    }

    @PostConstruct
    //表示bean初始化对应的操作
    public void init(){
        //System.out.println("init...");
    }

    @PreDestroy
    //表示bean销毁前对应的操作
    public void destory(){
        //System.out.println("destory...");
    }
}
 
@Service
public class BookServiceImpl implements BookService {
    @Autowired //暴力反射直接暴力加值,如修改访问方式
    @Qualifier("bookDao") //优先级又高于Autowired自带查找
    private BookDao bookDao2; //自动装配,先查找与参数名字匹配的bean,后查找参数类型匹配的bean

//    @Autowired
//    public void setBookDao(BookDao bookDao) {
//        this.bookDao = bookDao;
//    }

    @Override
    public void save() {
        System.out.println("book service save...");
        bookDao2.save();
    }
}
 
public class App {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
//        BookDao bookDao = ctx.getBean(BookDao.class);

        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        //ctx.registerShutdownHook();
        BookService bookService = ctx.getBean(BookService.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookService.save();
        //ctx.close();
    }
}
 
public class AppForAnnotation {
    public static void main(String[] args) {
//        DataSource dataSource = (DataSource) ctx.getBean("dataSource");
//        //ctx.registerShutdownHook(); //注册关闭钩子，在jvm虚拟机关闭之前关闭
//        System.out.println(dataSource);
        //具体关闭操作，在Tomcat里面实现
        //1.从类路径下加载配置文件
        //BeanFactoru延迟加载Bean而 ApplicationContext是立即加载Bean  相当于<!--    lazy-init="true" 延迟加载参数--> 即加载xml即创建bean与使用才创建
        //2.从文件系统下加载配置文件
//        ApplicationContext ctx = new FileSystemXmlApplicationContext("C:\\Users\\ncsf7\\IdeaProjects\\spring10-container\\src\\main\\resources\\applicationContext.xml");
        //3.加载多个配置文件
        //ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml", "a.xml");
//        方式一：使用bean名称
        //BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        方式二：使用bean名称并指定类型
//        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
//        方式三：使用bean类型获取
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        BookDao bookDao = ctx.getBean(BookDao.class); //相当于autowire=byType, 但是要是有俩个同类型就不行
        bookDao.save();
    }
}
 
public class AppForBeanFactory {
    public static void main(String[] args) {
        Resource resources = new ClassPathResource("applicationContext.xml"); //延迟加载Bean而 ApplicationContext是立即加载Bean
        BeanFactory bf = new XmlBeanFactory(resources);
//        BookDao bookDao = bf.getBean(BookDao.class);
//        bookDao.save();

    }
}

 
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">
<!--        1.导入spring的坐标spring-context，对应版本是5.2.10.RELEASE-->
<!--        2.配置bean-->
<!--            bean标签表示配置bean-->
<!--            id属性表示给bean起名字-->
<!--            class属性表示被bean定义类型-->


<!--     方式一：构造方法实例化bean     -->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" scope="prototype"/>-->
<!--     方式二：使用静态工厂实例化bean-->
<!--     <bean id="orderDao" class="com.rqiang.factory.OrderDaoFactory" factory-method="getOrderDao"/>-->
     <!--     方式二：使用实例工厂实例化bean-->
<!--     <bean id="userDaoFactory" class="com.rqiang.factory.UserDaoFactory"/>-->
<!--     <bean id="userDao" factory-bean="userDaoFactory" factory-method="getUserDao"/>-->
<!--     方式四： 使用FactoryBean 实例化bean-->

<!--     标准书写-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg name="connectionNum" value="100"/>-->
<!--          <constructor-arg name="databaseName" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->
<!--     解决形参名称的问题，与形参名不耦合-->
<!--     <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory">-->
<!--          <constructor-arg type="int" value="100"/>-->
<!--          <constructor-arg type="java.lang.String" value="mysql"/>-->
<!--     </bean>-->
<!--     <bean id="userDao" class="com.rqiang.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/>-->
<!--     <bean id="bookService" class="com.rqiang.service.impl.BookServiceImpl">-->
<!--          <constructor-arg name="bookDao" ref="bookDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--          <constructor-arg name="userDao" ref="userDao"/>                     &lt;!&ndash;name=形参&ndash;&gt;-->
<!--     </bean>-->

<!--     解决参数类型重复问题，使用位置解决参数匹配-->

<!--    管理DruidDateSource对象-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="url" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="username" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--    </bean>-->
<!--    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">-->
<!--        <property name="driverClass" value="com.mysql.jdbc.Driver"/>-->
<!--        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/db_ssm"/>-->
<!--        <property name="user" value="root"/>-->
<!--        <property name="password" value="123456"/>-->
<!--        <property name="maxPoolSize" value="1000"/>-->
<!--    </bean>-->
<!--    1.开启context命名空间-->
<!--    2.使用context空间加载properties文件-->
<!--    system-properties-mode="NEVER" 不加载系统属性 ✔-->
<!--    jdbc.properties, jdbc2.properties加载多个properties文件 -->
<!--    *properties 加载所有的properties文件 ×-->
<!--    classpath:*.properties 加载资源路径下的properties文件 ✔✔-->
<!--    classpath*:*.properties 加载导入jar包及资源路径下的properties文件 ✔-->
<!--    <context:property-placeholder location="classpath*:*.properties" system-properties-mode="NEVER"/>-->
<!--&lt;!&ndash;    3.使用属性占位符${}读取properties文件中的属性&ndash;&gt;-->
<!--    <bean class="com.alibaba.druid.pool.DruidDataSource">-->
<!--        <property name="driverClassName" value="${jdbc.driver}"/>-->
<!--        <property name="url" value="${jdbc.url}"/>-->
<!--        <property name="username" value="${jdbc.username}"/>-->
<!--        <property name="password" value="${jdbc.password}"/>-->
<!--    </bean>-->
<!--    lazy-init="true" 延迟加载参数-->
<!--    <bean id="bookDao" class="com.rqiang.dao.impl.BookDaoImpl"/>-->
<!--    核心配置文件中通过组件扫描加载bean-->
<!--    <context:component-scan base-package="com.rqiang.dao.impl"/>-->
    <context:component-scan base-package="com.rqiang"/>

<!--     自动装配用于应用类型依赖注入，不能对简单类型操作-->
<!--     按类型装配时(byType)必须保障容器中相同类型的bean唯一，推荐使用-->
<!--     按名称装配时(byName)必须保障容器中具有指定名称的bean，因为变量名和配置耦合，不推荐使用-->
<!--     自动装配autowire优先级低于setter注入与构造器注入，多种注入同时出现会自动装配配置失效-->
<!---->

     <!--        别名: <bean name="book1, book2; dao service"/>-->
<!--    spring bean 默认配置Single单例的bean对象，可以通过输出对象地址验证-->
<!--    默认为单例，可以通过修改bean配置属性更改为非单例 scope="singleton|prototype-->
<!--    如果关系绑定，不管绑定关系是什么作用范围都以IOC取出的对象Scope为准，如：bean为prototype，bookService为singleton，取出对象为singleton-->
<!--          7.配置service与dao的关系-->
<!--          property标签表示配置当前bean的属性-->
<!--          name属性表示配置哪一个具体的属性，即set+name的name方法名-->
<!--          ref属性表示参照哪一个bean-->


</beans>

<!--适合交给IOC容器管理的bean-->
<!--    表现层对象-->
<!--    业务层对象-->
<!--    数据从对象-->
<!--    工具对象-->
<!--不适合交给IOC容器管理的bean-->
<!--    封装实体的域对象-->
 
Spring14
@Configuration //代表applicationContext.xml Spring配置文件的壳
//设定当前类为配置类
//@ComponentScan("com.rqiang")  //相当于<context:component-scan base-package="com.rqiang"/>   //14中:也可以使用此方法扫描另外的配置文件
//此注解只能添加一次,多个数据使用数组格式  @ComponentScan({"com.rqiang", "com.jx3hyun"})
//@PropertySource("jdbc2.properties")
//@PropertySource("classpath:jdbc2.properties")
//数据源,说是哪个配置文件,不支持使用*通配符 多文件用@PropertySource({"jdbc2.properties", "dasd.properties"})
@Import({JdbcConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {
}


public class JdbcConfig {
    //1.定义一个方法获得要管理的bean
    //2.添加@bean表示当前返回的方法是一个bean
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/db_ssm");
        ds.setUsername("root");
        ds.setPassword("123456");
        return ds;
    }
}
//1.定义一个方法获得要管理的bean
//2.添加@bean表示当前返回的方法是一个bean
@Value("com.mysql.jdbc.Driver")
private String driver;
@Value("jdbc:mysql://localhost:3306/db_ssm")
private String url;
@Value("root")
private String userName;
@Value("123456")
private String password;

@Bean
public DataSource dataSource(BookDao bookDao){ //引用类型注入: 定义方法设置形参,容器会根据类型自动装配对象
    System.out.println(bookDao);
    DruidDataSource ds = new DruidDataSource();
    ds.setDriverClassName(driver);
    ds.setUrl(url);
    ds.setUsername(userName);
    ds.setPassword(password);
    return ds;
}

 
Spirng15
public class JdbcConfig {
    @Value("${jdbc.driver}")
    public String driver;
    @Value("${jdbc.url}")
    public String url;
    @Value("${jdbc.username}")
    public String username;
    @Value("${jdbc.password}")
    public String password;

    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
 
public class MybatisConfig {

    @Bean
    public SqlSessionFactoryBean SqlSessionFactory(DataSource dataSource){
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        //ssfb.setTypeAliasesPackage("com.rqiang.domain");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer(){
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.rqiang.dao");
        return msc;
    }
}

 
@Configuration
@ComponentScan("com.rqiang")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {

}
 
public class App2 {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        AccountService accountService = ctx.getBean(AccountService.class);

        Account ac = accountService.findById(2);

        System.out.println(ac);
    }
 
Spring16
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceTest {

    @Autowired
    private AccountService accountService;

    @Test
    public void testFindById(){
        System.out.println(accountService.findById(1));
    }
}




 
Spring17
//AOP在不惊动原始程序的基础上，对其进行功能增强
    //Spring理念：无侵入式编程

通知类-----通知 ---–（切面）----> 切入点匹配---连接点

连接点(JoinPoint): 程序执行过程中任意的位置，粒度为执行方法、抛出异常、设置变量等
在SpringAOP中，理解为方法的执行

切入点(Pointcut): 匹配连接点的式子
在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法
一个具体方法: com.rqiang.dao包下的BookDao接口中的无形参无返回值的save方法
匹配多个方法: 所有的save方法，所有的get开头的方法，所有的Dao结尾的接口中的任意方法，所有带有一个参数的方法

通知(Advice): 在切入点处执行的操作，也就是共性功能
  在SpringAOP中, 功能最终以方法的形式呈现

通知类: 定义通知的类

切面(Aspect): 描述通知与切入点的对应关系
 
Spring18
@Component //springIOC控制
@Aspect  //AOP处理标识
public class MyAdvice {

    @Pointcut("execution(void com.rqiang.dao.BookDao.update())") //设置切入点位置
    private void pt(){//定义切入点，私有方法空壳
    }

    @Before("pt()") //绑定共性功能
    public void method(){  //名称随意，共性功能
        System.out.println(System.currentTimeMillis());
    }
}

1.	导入aop相关坐标
2.	定义dao接口与实现类
3.	定义通知类，制作通知
4.	定义切入点
切入点定义依托一个无实际意义的方法进行，空壳方法，无参，无return，方法体无逻辑
5.	绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置
6.	定义通知类受Spring容器管理，并定义当前类为切面类
7.	开启Spring对AOP注解驱动支持



 
@Configuration
@ComponentScan("com.rqiang")
@PropertySource("classpath:jdbc.properties")
@EnableAspectJAutoProxy //标识程序是使用 @Aspect注解开发的AOP
//@Import({JdbcConfig.class, MybatisConfig.class}) //.class文件可以不需要@Configuration
public class SpringConfig {

}


 

AOP工作流程
1.	Spring容器启动
2.	读取所有切面配置中的切入点 //那个无实际意义的方法
3.	初始化bean，判定bean对应的类中的方法是否匹配到任意切入点
匹配失败，创建对象
匹配成功，创建原始对象（目标对象）的代理对象
4.	获取bean执行方法
获取bean，调用方法执行，完成操作
获取bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作

目标对象(Target): 仅存原始功能，而无共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的
代理(Proxy): 目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现



切入点表达式
Execution 动作修饰符
Public 可以省略
返回值
类/接口名
方法名
参数
异常 可以省略


切入点可以使用通配符
*： 单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现
Execution(public * com.rqiang.*.UserService.find*(*))
  匹配com.rqiang包下的任意包中的UserService类或接口中所有find开头带一个参数的方法

.. : 多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 //尽量不用，效率低
Execution(public User com..UserService.findById(..))
  匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法
+ : 专用于匹配子类类型
Execution(* *..*Service+.*(..))

(*)必须带一个参数，(..)任意参数0或1或多，*e或e* 以e结尾或者以e开头的方法（可*为空）
* 任意返回值
@Pointcut("execution(* com.rqiang.*.*Dao.update*(..))")

 
Spring19
@Before("pt()") //绑定共性功能, 描述的是抽取的共性功能，根据共性绑定的位置不同，最终运行代码会加入的合理的位置
//    前置通知*
//    后置通知*
//    环绕通知**
//    返回后通知
//    抛出异常后通知


@Component //springIOC控制
@Aspect  //AOP处理标识
public class MyAdvice {

//    @Pointcut("execution(void com.rqiang.dao.BookDao.update())") //设置切入点位置
//    @Pointcut("execution(void com.rqiang.dao.impl.BookDaoImpl.update())") //设置切入点位置
//  @Pointcut("execution(* com.rqiang.*.*Dao.update*(..))")
    @Pointcut("execution(* com.rqiang.dao.*BookDao.update(..))")
    private void pt(){//定义切入点，私有方法空壳
    }
    @Pointcut("execution(* com.rqiang.dao.*BookDao.select(..))")
    private void pt2(){//定义切入点，私有方法空壳
    }

    //@Before("MyAdvice.pt()")
//    @Before("pt()") //绑定共性功能, 描述的是抽取的共性功能，根据共性绑定的位置不同，最终运行代码会加入的合理的位置
//    前置通知*
//    后置通知*
//    环绕通知**
//    返回后通知
//    抛出异常后通知
    public void before(){  //名称随意，共性功能
        System.out.println("before advice..");
    }

//    @After("pt()")
    public void after(){
        System.out.println("after advice..");
    }

    //@Around("pt()")
    public void around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("before advice..");
        pjp.proceed();//表示对原始操作的调用
        System.out.println("after advice..");
    }
    @Around("pt2()") //环绕通知需要把返回值接进来再送出去
    public Object aroundSlect(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("before advice..");
        Object ret = pjp.proceed();//表示对原始操作的调用
        System.out.println("after advice..");
        return ret;
    }

//    @AfterReturning("pt2()") //没抛异常正常时候才运行，@After异常时也运行，异常正常抛出
 
//    @AfterThrowing("pt2()") // 抛出异常才运行，没抛出异常不运行

}
 
Spring20


@Component
@Aspect
public class ProjectAdvice {
    //匹配业务层的所有方法
    @Pointcut("execution(* com.rqiang.service.*Service.*(..))")
    private void servicePt(){}

    @Around("ProjectAdvice.servicePt()")
    public void runSpeed(ProceedingJoinPoint pjp) throws Throwable {
        //获取执行签名信息
        Signature signature = pjp.getSignature();
        //通过签名获取执行类型（接口名）
        String className = signature.getDeclaringTypeName();
        //通过签名会哦去执行操作名称（方法名）
        String methodName = signature.getName();
        long start = System.currentTimeMillis();
        for(int i = 0; i < 10000; i++)
            pjp.proceed();
        long end = System.currentTimeMillis();
        System.out.println("万次执行：" + className + "." + methodName + (end - start) + "ms");
    }

 
Spring21

获取切入点方法参数
JoinPoint: 适合前置，后置，返回后，抛出异常后通知
ProceedJointPoint: 适用于环绕通知

获取切入点方法返回值
返回后通知
环绕通知

获取切入点方法运行异常信息
抛出异常后通知
环绕通知



public class BookDaoImpl implements BookDao {
    @Override
    public String findName(int id, String name){
        System.out.println("id: " + id);
        if(true) throw new NullPointerException();
        return "itcast";
    }
}

 
@Component
@Aspect
public class MyAdvice {
    //匹配业务层的所有方法
    @Pointcut("execution(* com.rqiang.dao.*Dao.find*(.. ))")
    private void daoPt(){}

//    @Before("daoPt()")
    public void before(JoinPoint jp){
        Object[] args = jp.getArgs();
        System.out.println(Arrays.toString(args));
        System.out.println("before advice ..");
    }


    //@Around("daoPt()")
    public void runSpeed(ProceedingJoinPoint pjp) throws Throwable {
//        //获取执行签名信息
//        Signature signature = pjp.getSignature();
//        //通过签名获取执行类型（接口名）
//        String className = signature.getDeclaringTypeName();
//        //通过签名会哦去执行操作名称（方法名）
//        String methodName = signature.getName();
        Object[] args = pjp.getArgs();
        System.out.println(Arrays.toString(args));
        args[0] = 11;
//        long start = System.currentTimeMillis();
//        for(int i = 0; i < 10000; i++)
            pjp.proceed(args);
//        long end = System.currentTimeMillis();
//        System.out.println("万次执行：" + className + "." + methodName + (end - start) + "ms");
    }

    //@AfterReturning(value = "daoPt()", returning = "ret") //返回返回值吗，returning值 必须 等于形参名
    public void afterRuturning(Object ret){ //JoinPoint 有的话 必须放第一个
        System.out.println("afterReturning ..." + ret);
    }

    @AfterThrowing(value = "daoPt()",throwing = "t")
    public void afterThrowing(Throwable t){
        System.out.println("afterThrowing advice ..." + t);
    }
}
 
Spring22
ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
ResourceService resourceService = ctx.getBean(ResourceService.class);
boolean flag = resourceService.openURL("http://www.baidu.com/hh", "12345678  ");
System.out.println(flag);


@Around("serviceFun()")
public Object aroundFun(ProceedingJoinPoint pjp) throws Throwable {
    Object[] args = pjp.getArgs();
    for(int i = 0; i<args.length; i++){
        if(args[i].getClass().equals(String.class)){
            args[i] = args[i].toString().trim();
        }
    }
    Object ret = pjp.proceed(args);
    return ret;
}

 
Spring23
@Configuration
@ComponentScan("com.rqiang")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class}) //.class文件可以不需要@Configuration
@EnableTransactionManagement //开启事务
@EnableAspectJAutoProxy //aop注解开发
public class SpringConfig {

}



Jdbc类
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource){
    DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();
    transactionManager.setDataSource(dataSource);
    return transactionManager;
}



Service层方法
@Transactional
public void transfer(String out, String in, Double money);

//只有 errorzero和 notpoint 和 arraymax 等才会回滚，其他异常需要设置@Transactional(rollbackFor = {IOException.class})
//int i = 1/0;


事务传播行为：事务协调员对事务管理员所携带事务的处理态度
@Transactional(propagation = Propagation.REQUIRES_NEW) 新建事务
@Transactional(propagation = Propagation.REQUIRES)  有 加入，无 新建


        try{
            accountDao.outMoney(out, money);
//            int i = 1/0;
            accountDao.inMoney(in, money);
            logService.log(out + "Successful！", in, money);
        }catch (Exception e){
            logService.log(out + "Error！", in, money);
            throw e;
        }

